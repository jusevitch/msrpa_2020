#!/usr/bin/env python

# 
#      ____  ___   _____ ______   __          __    
#     / __ \/   | / ___// ____/  / /   ____ _/ /_   
#    / / / / /| | \__ \/ /      / /   / __ `/ __ \  
#   / /_/ / ___ |___/ / /___   / /___/ /_/ / /_/ /  
#  /_____/_/  |_/____/\____/  /_____/\__,_/_.___/   
#                                                   
# 
# Author: James Usevitch
# 
# Description: This file contains the input/output linearization controller for the
#              AION R1 Rover. Obstacle avoidance and input constraint satisfaction
#              is calculated using a control barrier function and QP method.
# 


import rospy
import sys
import osqp
import numpy as np
from numpy import cos, sin, arccos
from scipy.sparse import csc_matrix
import tf.transformations as trans # For quaternion operations
import argparse
from copy import deepcopy

import trajectory

# Import messages
from geometry_msgs.msg import Twist
from gazebo_msgs.msg import ModelStates
from geometry_msgs.msg import Quaternion
from msrpa_2020.msg import SimpleMSRPA




class IO_controller_R1:

    
    traj_func = {
        "circular": trajectory.circular2D,
        "linear": trajectory.linear2D
        # "polynomial": trajectory.polynomial3D
    }

    patterns = ['rover', 'quad','obstacle']

    pub = rospy.Publisher('cmd_vel_mux/input/teleop', Twist, queue_size=1) # Double check to make sure this has correct namespace later

    def __init__(self,
        local_offset = np.zeros(2),
        b = 0.1, 
        kp = 5,
        kd = 1,
        delta = 1,
        P = csc_matrix(np.identity(2)),
        input_Hz = 10,
        vmax = 1,
        wmax = 2,
        Au = np.array([]),
        bu = np.array([]),
        t0 = np.inf, 
        trajectory_type = "circular", 
        vel_msg = Twist(),
        objectStates = ModelStates(),
        subscriber_topic = "/gazebo/model_states",
        rover_namespace = "rover0",
        R_factor = 0.5
    ):
        self.state = np.zeros(3)
        self.local_offset = local_offset 
        self.b = b  # Parameter for Siciliano input / output controller
        self.kp = kp
        self.kd = kd
        self.delta = kd # Parameter for class-K function in QP
        self.P = P
        self.input_Hz = input_Hz
        self.vmax = vmax
        self.wmax = wmax
        self.Au = Au
        self.bu = bu
        self.t0 = t0 # Initial time
        self.trajectory_type = trajectory_type # Types can be None, circular, square, polynomial
        self.vel_msg = vel_msg
        self.objectStates = objectStates
        self.subscriber_topic = subscriber_topic
        self.rover_namespace = rover_namespace
        self.R = b + R_factor # Different than quadcopter

        rospy.Subscriber(subscriber_topic, ModelStates, self.object_callback)
        rospy.Timer(rospy.Duration(1.0/self.input_Hz), self.IOcallback)
        MSRPA_sub = rospy.Subscriber('/MSRPA/' + self.rover_namespace, SimpleMSRPA, self.MSRPA_callback)



    def IOcallback(self, msg):
        # Current time
    
        # Calculate normalized time
        if self.t0 is np.inf or self.t1 is np.inf:
            # The agent hasn't properly received a trajectory, so do nothing.
            return
        else:
            time_now = rospy.get_rostime().to_sec()
            if time_now < self.t0:
                t = 0.0
            elif time_now > self.t1:
                t = 1.0
            else:
                t = (time_now - self.t0) / (self.t1 - self.t0)
    
            # Object states
            currentObjectStates = deepcopy(self.objectStates)
            
            if (self.rover_namespace in currentObjectStates.name):
                state_index = currentObjectStates.name.index(self.rover_namespace) # Gets the index of agent state info
                self.state[0] = currentObjectStates.pose[state_index].position.x
                self.state[1] = currentObjectStates.pose[state_index].position.y
                self.state[2] = determine_theta(currentObjectStates.pose[state_index].orientation)
    
    
                # Find the indices for all rovers, quads, and objects specifically labeled "obstacle"
                # The array 'patterns' is defined above in the global scope
                reduced_indices = [currentObjectStates.name.index(s) for s in currentObjectStates.name if any(xs in s for xs in self.patterns)]
                
                # Remove the index for this agent's own information
                if state_index in reduced_indices:
                    reduced_indices.remove(state_index)
    
                # Solve for center of formation and formation frame state
                if self.trajectory_type is not None and self.trajectory_data is not None:
                    if self.trajectory_type == "circular":
                        formation_state, deriv_formation_state = self.traj_func[self.trajectory_type](time_now - self.t0,self.trajectory_data)
                    else:
                        formation_state, deriv_formation_state = self.traj_func[self.trajectory_type](t,self.trajectory_data)
     
                    # Determine local target point and derivative as offset from the formational center
                    if np.any(self.local_offset != np.array([0.0, 0.0])):
                        p, dp = formation_offset(formation_state, deriv_formation_state, self.local_offset)
                    else:
                        p = formation_state[0:2]
                        dp = deriv_formation_state[0:2]
                else:
                    p = self.state[0:2]
                    dp = np.zeros(2)
    
                
                uhat = self.nominal_ctrl_untransformed(p, dp)
    
                # Location of the b point for IO controller
                b_state = self.state[0:2] + np.array([self.b*cos(self.state[2]), self.b*sin(self.state[2])])
                
                
                # TODO: This currently assumes everything has the same safety radius.
                #       Need to create a parameter server which lists the safety radii of all nodes.
                # R = b + 0.5
                Ro = 2.0
    
    
                # Infinity norm constraint matrix for untransformed input
                Au_untr = np.array([[cos(self.state[2]), sin(self.state[2])],
                                    [-cos(self.state[2]), -sin(self.state[2])],
                                    [-sin(self.state[2])/self.b, cos(self.state[2])/self.b],
                                    [sin(self.state[2])/self.b, -cos(self.state[2])/self.b]])
    
                if len(reduced_indices) > 0:
                    A = np.zeros((len(reduced_indices),2))
                    bvec = np.zeros(len(reduced_indices))
    
                    for i in range(len(reduced_indices)):
                        idx = reduced_indices[i]
                        obstacle_state = np.array([currentObjectStates.pose[idx].position.x, currentObjectStates.pose[idx].position.y])
    
                        # A[i,:] = dhdx(state,obstacle_state).dot(g(state))
                        A[i,:] = -1.0*dhdx_single_int(b_state,obstacle_state)
                        bvec[i] = self.delta*h(b_state,obstacle_state,self.R,Ro)
    
                    # Add the infinity norm input constraints
                    # A = np.append(A,Au,axis=0) # for untransformed inputs
                    A = np.append(A,Au_untr,axis=0) # for untransformed inputs
                    bvec = np.append(bvec,bu,axis=0)
                else:
                    # A = Au
                    A = Au_untr
                    bvec = bu
    
                
                # If the nominal controller is feasible, skip the QP.
                if (np.max(A.dot(uhat) - bvec) <= 0.0):
                    u = uhat
                else:
                    # Minimally modify nominal controller with CBF QP
                    # OSQP assumes the form (1/2)u^T P u + q^T u
                    q = -uhat
    
                    model = osqp.OSQP()
                    model.setup(P=self.P, q=q, A=csc_matrix(A), u=bvec, verbose=False)
                      
                    results = model.solve()
    
                    # Set u equal to results if the problem was solved; otherwise set it to zero
                    # See https://osqp.org/docs/interfaces/status_values.html#status-values for status_val values
                    if(results.info.status_val == 1 or results.info.status_val == 2):
                        u = results.x
                    else:
                        print("\nstatus_val did NOT RETURN 1 OR 2")
                        u = np.zeros(2)
    
                # Transform by the T matrix
                # Only use this if you use the nominal_ctrl_untransformed function
                Tmatrix = self.T(self.state[2])
                u = Tmatrix.dot(u)
                
                self.vel_msg.linear.x = u[0]
                self.vel_msg.angular.z = u[1]
    
                self.pub.publish(self.vel_msg)
    



    
    def T(self, theta):
        return np.array([[cos(theta), sin(theta)],[-sin(theta)/self.b, cos(theta)/self.b]])



    def nominal_ctrl(self, point, point_deriv):

        # Assumes that all inputs are numpy arrays
        y1 = self.state[0] + self.self.b*cos(self.state[2])
        y2 = self.state[1] + self.self.b*sin(self.state[2])
    
        u = np.zeros(2)
        u[0] = self.kd*point_deriv[0] + self.kp*(point[0] - y1)
        u[1] = self.kd*point_deriv[1] + self.kp*(point[1] - y2)
    
        Tmatrix = T(self.state[2])
        return Tmatrix.dot(u)



    def nominal_ctrl_untransformed(self, point, point_deriv):
        # This controller does not transform the u values by the T(theta) matrix.
        # See Siciliano 2009, _Robotics_, Ch. 11, eq. 11.74 for details
    
        # Assumes that all inputs are numpy arrays
        y1 = self.state[0] + self.b*cos(self.state[2])
        y2 = self.state[1] + self.b*sin(self.state[2])
    
        u = np.zeros(2)
        u[0] = self.kd*point_deriv[0] + self.kp*(point[0] - y1)
        u[1] = self.kd*point_deriv[1] + self.kp*(point[1] - y2)
    
        return u




    def object_callback(self, msg):
        # Updates the global obstacleStates
        # Using globals is terrible programming practice and needs to be changed later.
        self.objectStates = deepcopy(msg)




    def MSRPA_callback(self, msg):
        self.trajectory_type = msg.trajectory_type
        self.trajectory_data = msg.data
        self.t0 = msg.data[0]
        self.t1 = msg.data[1]

        if self.trajectory_type == "linear":
            print("\n{} has linear traj type".format(rover_namespace))



def h(x,xo,R,Ro):
    # x and xo refer to the positional (x,y) state of the agent (x) and obstacle (xo)
    return (np.linalg.norm(x[0:2] - xo, 2))**2 - (max(R,Ro))**2

def dhdx(x,xo):
    # x and xo refer to the positional (x,y) state of the agent (x) and obstacle (xo)
    return 2*np.array([x[0]-xo[0], x[1]-xo[1], 0])

def dhdx_single_int(x,xo):
    return 2*np.array([x[0]-xo[0], x[1]-xo[1]])

def g(x):
    return np.array([[cos(x[2]), 0], [sin(x[2]), 0], [0,1]])

def determine_theta(quaternion, tolerance=0.01):
    # Determines a (very rough) approximation of theta by projecting the forward direction axis of the agent
    # (assumed to be x-axis) onto the ground plane (x-y plane in Gazebo). This operation can be undefined,
    # so be careful and make sure that your agents never have their forward axis pointing perpendicular
    # to the ground plane.

    # Tolerance determines how close the x-axis must be to vertical before returning an error. This
    # will need to be improved in future versions.

    # print("\n input quaternion:")
    # print(quaternion)

    # Quaternion must be either numpy vector or geometry_msgs/Quaternion message
    if type(quaternion) is Quaternion:
        rotation_quaternion = np.array([0.0,0.0,0.0,0.0])
        rotation_quaternion[0] = quaternion.x
        rotation_quaternion[1] = quaternion.y
        rotation_quaternion[2] = quaternion.z
        rotation_quaternion[3] = quaternion.w
    else:
        rotation_quaternion = quaternion

    quat_vector = np.array([1,0,0,0]) # x-axis in local frame
    # Perform the quaternion rotation qvq^-1
    quat_vector = trans.quaternion_multiply(rotation_quaternion, quat_vector)
    quat_vector = trans.quaternion_multiply(quat_vector, trans.quaternion_conjugate(rotation_quaternion))

    # Project resulting vector onto the x-y plane and normalize
    two_dim_vec = np.array([quat_vector[0], quat_vector[1]])
    if np.linalg.norm(two_dim_vec) < tolerance:
        # Debug
        print("\ntwo_dim_vec value: " + str(two_dim_vec) + "\n")
        # /Debug
        print('Cannot determine theta: x-vector is too close to vertical. Check model poses or change the tolerance.')
    
    # Determine theta as angle between two_dim_vector and x-axis of global frame
    # If two_dim_vec is zero, return an error...TODO
    abs_theta = arccos(two_dim_vec.dot(np.array([1,0]))/np.linalg.norm(two_dim_vec)) 
    if (two_dim_vec[1] >= 0):
        return abs_theta
    else:
        return -abs_theta



def formation_offset(formation_state, deriv_formation_state, offset_vector):
    # Calculates an agent's desired formational position as an offset from the center of formation

    # This assumes that there exists a formational frame defined by:
    #   * A point acting as the center of formation
    #   * A directional vector acting as the x axis of the frame
    # For now, the formational frame xy plane is assumed to be parallel to the flat ground xy plane.
    # In addition, addition, the offset vector is assumed to not be time-varying.
    #
    # Inputs:
    #
    # formation_state:          The state of the formation. A numpy array with the form [xc, yc, phi] where
    #                           (xc,yc,zc) are the coordinates of the center of formation point and phi is the
    #                           rotational angle (about the global z-axis) from the global x-axis to the 
    #                           formational frame x axis.
    #
    # deriv_formation_state:    The time derivative of formation_state. A numpy vector with the form
    #                           [dxc, dyc, dphi], where d represents the time derivative.
    #
    # offset_vector:            The offset vector from the formational center resolved in the formational frame.
    #                           A numpy vector of the form [x, y]
    # 
    # Outputs:
    #
    # output_point:             A numpy vector containing the formational offset point resolved in the global
    #                           frame. 
    #
    # deriv_output_point:       A numpy vector containing the time derivative of output_point
    #
    # output_velocity: A numpy vector containing the velocity of the offset point
    
    phi = formation_state[2]
    rotation_matrix = np.array([[cos(phi), -sin(phi)],[sin(phi), cos(phi)]])
    output_point = rotation_matrix.dot(offset_vector) + formation_state[0:2] 

    dphi = deriv_formation_state[2]
    deriv_rotation_matrix = dphi*np.array([[-sin(phi), -cos(phi)],[cos(phi), -sin(phi)]])
    deriv_output_point = deriv_rotation_matrix.dot(offset_vector) + deriv_formation_state[0:2]

    return (output_point, deriv_output_point)






if __name__ == '__main__':
    # Takes inputs from command line. 
    # Note that any unexpected inputs passed into argparse will throw an error.

    # rospy.myargv removes ROS custom inputs from the argv vector
    myargv = rospy.myargv(argv=sys.argv)

    # Removes the filename from the arguments. Required when manually passing the array into the parse_args() function.
    myargv = myargv[1:]     
   
    # Parse arguments
    parser = argparse.ArgumentParser(description='IO_controller_R1 : Node containing the QP controller for R1 Rovers.')
    parser.add_argument('--rover_namespace', help="The namespace of the rover; i.e. rover0.")
    parser.add_argument('--formation_x', type=float, help='The local formational x-axis offset of the agent in the formation frame.')
    parser.add_argument('--formation_y', type=float, help='The local formational y-axis offset of the agent in the formation frame.')
    parser.add_argument('--instant_start', action="store_true", help='Starts the trajectory immediately upon the node launching.')
    parser.add_argument('--vmax', type=float, help='Max v command limit')
    parser.add_argument('--wmax', type=float, help='Max w command limit')
    parser.add_argument('--kd', type=float, help='Derivative gain')
    parser.add_argument('--kp', type=float, help='Proportional gain')
    parser.add_argument('--input_Hz', type=float, help='Hz rate for the controller callback function')
    args = parser.parse_args(myargv)
    
    if args.rover_namespace is not None:
        rover_namespace = args.rover_namespace
        print("The rover namespace is " + rover_namespace)
    else:
        rover_namespace = 'rover0'

    local_offset = np.zeros(2)

    if args.formation_x is not None:
        local_offset[0] = args.formation_x

    if args.formation_y is not None:
        local_offset[1] = args.formation_y

    if args.vmax is not None:
        vmax = args.vmax
    else:
        vmax = 1

    if args.wmax is not None:
        wmax = args.wmax
    else:
        wmax = 1

    if args.kp is not None:
        kp = args.kp

    if args.kd is not None:
        kd = args.kd

    if args.input_Hz is not None:
        input_Hz = args.input_Hz
    else:
        input_Hz = 10

    
    Au = np.array([[1,0],[-1,0],[0,1],[0,-1]])
    bu = np.array([vmax, vmax, wmax, wmax])


    try:
        rospy.init_node('R1_qp_control')

        IO_rover_node = IO_controller_R1(
           kp=kp,
           kd=kd,
           Au=Au,
           bu=bu,
           vmax=vmax,
           wmax=wmax,
           local_offset=local_offset,
           rover_namespace=rover_namespace,
           input_Hz=input_Hz
        )

        rospy.spin()
    except rospy.ROSInterruptException: pass
