#!/usr/bin/env python

# 
#      ____  ___   _____ ______   __          __    
#     / __ \/   | / ___// ____/  / /   ____ _/ /_   
#    / / / / /| | \__ \/ /      / /   / __ `/ __ \  
#   / /_/ / ___ |___/ / /___   / /___/ /_/ / /_/ /  
#  /_____/_/  |_/____/\____/  /_____/\__,_/_.___/   
#                                                   
# 
# Author: James Usevitch
# 
# Description: This file contains the input/output linearization controller for the
#              Hector Quadrotor model in Gazebo. Obstacle avoidance and input constraint satisfaction
#              is calculated using a control barrier function and QP method.
# 


import rospy
import sys
import numpy as np
import argparse
from copy import deepcopy
from msrpa_2020.msg import SimpleMSRPA
from collections import Counter # For efficiently counting message types

# AGENT NUMBERING:
#
# This approach assumes the following numbering:
# Quads are named quad_0 ... quad_(n_quads-1)
# Rovers are named rover_(n_quads) ... rover_(n_quads + n_rovers - 1)
# This is to help make identifying the rows of the Laplacian matrix relating
# to leaders and malicious agents easier
# 
# FOR EXAMPLE, if 2 quads, 2 rovers then the agent list is
# quad0, quad1, rover2, rover3

class MSRPA_node:
    def __init__(self, n_quads=0, n_rovers=0, leader_list=[], malicious_list=[], A=np.array([],dtype=int), input_Hz=10.0, eta=1, F=0, leader_message=SimpleMSRPA()):
        self.n_quads = n_quads
        self.n_rovers = n_rovers
        self.n = n_quads + n_rovers
        self.leader_list = leader_list
        self.malicious_list = malicious_list
        self.A = A
        self.eta = eta
        self.F = F

        self.timestep = 0

        self.normal_list = [i for i in range(self.n) if i not in self.leader_list + self.malicious_list]

        self.broadcast_matrix = np.zeros(self.A.shape)
        self.broadcast_matrix[:,self.leader_list] = self.A[:,self.leader_list]
        print("\nBroadcast matrix:")
        print(self.broadcast_matrix)

        self.pubtopics = ["quad" + str(nq) for nq in range(n_quads)]
        self.pubtopics += ["rover" + str(n_quads + nr) for nr in range(n_rovers)]
        self.publist = [rospy.Publisher(topic, SimpleMSRPA, queue_size=1) for topic in self.pubtopics]

        self.leader_sub = rospy.Subscriber("leader_MSRPA", SimpleMSRPA, self.change_leader_message)

        self.timer = rospy.Timer(rospy.Duration(1.0/input_Hz), self.MSRPA_callback)
        
        self.received_messages = [SimpleMSRPA() for i in range(self.n)]    # Preallocation. May or may not help.
        print("\nself.received_messages")
        print(self.received_messages)

        self.empty_msg = SimpleMSRPA() # For comparison purposes

        # TODO : Fix the below
        self.MSRPA_list = [SimpleMSRPA() for i in range(self.n)]
        for i in self.leader_list:
            self.MSRPA_list[i] = leader_message

        for j in self.malicious_list:
            # self.MSRPA_list[j] = self.gen_malicious_message(j)
            self.MSRPA_list[j] = SimpleMSRPA()
            self.MSRPA_list[j].trajectory_type = "linear"
            self.MSRPA_list[j].data = [10, 4, 5, 11]




   
    def MSRPA_callback(self, leader_messages):
        # Do the main callback function
        
        print("\nself.MSRPA_list:")
        print(self.MSRPA_list)

        # Reset at intervals of eta
        if self.timestep == 0:
            self.broadcast_matrix[:,self.normal_list] = 0.0
            self.broadcast_matrix[:,self.leader_list] = self.A[:,self.leader_list]
            self.broadcast_matrix[:,self.malicious_list] = self.A[:,self.malicious_list]

        # Broadcast
        # ith column of A matrix contains out-neighbors of agent i
        # ith row of A matrix contains in-neighbors of agent i
        for i in self.normal_list:
            received_from = np.nonzero(self.broadcast_matrix[i,:])[0]
            self.received_messages[i] = [self.MSRPA_list[j] for j in received_from]
            print("\nReceived from, i={}".format(i))
            print(received_from)

            
            self.select_message(i, self.received_messages[i])


        # Send to Publishers 
        for j in range(self.n):
            if self.MSRPA_list[j] != self.empty_msg:
                self.publist[j].publish(self.MSRPA_list[j])
        

        self.timestep += 1
        self.timestep %= eta

        print("\ntimestep: {}".format(self.timestep))
        print("\nBroadcast_matrix at timestep {}".format(self.timestep))
        print(self.broadcast_matrix)

        print("\nsefl.MSRPA_list:")
        print(self.MSRPA_list)



    def select_message(self, number, received_messages):
        # Return None if there aren't at least 2F+1 messages
        if len(received_messages) < (2*F+1):
            print("\nNumber of received messages was too low for agent {}".format(number))
            return None
        
        print(received_messages)
        count = Counter([n.trajectory_type for n in received_messages])
        del count['']
        
        # Return None if there aren't at least F+1 messages of the same trajectory type
        if count.most_common()[0][1] < (F+1):
            print("\nMost common was {} for agent {}".format(count.most_common()[0][0], number))
            return None

        print("This happened for number={}".format(number))
        # Collect all messages of the most common type
        msg_type = count.most_common()[0][0]
        matching_types = [msg for msg in received_messages if msg.trajectory_type == msg_type]

        # Take median on all elementwise entries
        # TODO: Preallocate this matrix?
        data_matrix = np.stack([msg.data for msg in matching_types])
        median_matrix = np.median(data_matrix, axis=0)

        # Update the agent's broadcasted message
        self.MSRPA_list[number].trajectory_type = msg_type
        self.MSRPA_list[number].data = median_matrix.tolist()

        # Update the broadcast matrix
        self.broadcast_matrix[:,number] = self.A[:,number]

    
    def change_leader_message(self,msg):
        for i in self.leader_list:
            self.MSRPA_list[i] = msg


    def gen_malicious_message(self, number, malicious_message=SimpleMSRPA()):
        # TODO
        if type(number) is int:
            self.MSRPA_types[number] = malicious_message # Insert malicious message here
        else:
            raise ValueError("Input 'number' to gen_malicious_message is not an int")


# DELETE THESE? Python function calls throttle the speed significatnly

# def MSRPA_init():
    # Initialize all values


# def MSRPA_main():
    # Run the main loop here





def parse_Adjacency(flat_A):
    
    n = np.sqrt(len(flat_A))
    if int(n) != n:
        raise RuntimeError('Incorrect number of Adjacency matrix entries: not a square Adjacency matrix.')
    else:
        n = int(n)
        A = np.array(flat_A)
        A = A.reshape((n,-1))

    return A




if __name__ == "__main__":
    # Takes inputs from command line. 
    # Note that any unexpected inputs passed into argparse will throw an error.

    # rospy.myargv removes ROS custom inputs from the argv vector
    myargv = rospy.myargv(argv=sys.argv)

    # Removes the filename from the arguments. Required when manually passing the array into the parse_args() function.
    myargv = myargv[1:]     
    
    parser = argparse.ArgumentParser(description='msrpa : Node simulating the MS-RPA algorithm for all agents.')
    parser.add_argument('--n_quads', type=int, help="The number of quads in the network.")
    parser.add_argument('--n_rovers', type=int, help="The number of rovers in the network.")
    parser.add_argument('--eta', type=float, help="The parameter eta from the MS-RPA algorithm")
    parser.add_argument('--F', type=float, help="The parameter F from the MS-RPA algorithm. Must be more than number of adversaries.")
    parser.add_argument('--leader_list', nargs='+', type=int, help="Comma-separated list of leader agents, as per MSRPA numbering scheme")
    parser.add_argument('--malicious_list', nargs='+', type=int, help="Comma-separated list of malicious agents, as per MSRPA numbering scheme")
    parser.add_argument('--input_Hz', type=float, help="Hz rate at which to run the MS-RPA algorithm")
    # parser.add_argument('--L', nargs='+', type=int, help="Laplacian matrix. Input as 1D array with rows appended together.")
    args = parser.parse_args(myargv)

    if args.n_quads is not None:
        n_quads = args.n_quads
        
    if args.n_rovers is not None:
        n_rovers = args.n_rovers

    if args.eta is not None:
        eta = args.eta

    if args.F is not None:
        F = args.F

    if args.leader_list is not None:
        leader_list = args.leader_list

    if args.malicious_list is not None:
        malicious_list = args.malicious_list

    if args.input_Hz is not None:
        input_Hz = args.input_Hz

    leader_message = SimpleMSRPA()
    leader_message.trajectory_type = "linear"
    leader_message.data = [1.0, 2.0, 3.0, 4.0]

    try:
        rospy.init_node('MSRPA_master')

        n = n_quads + n_rovers

        while(not rospy.has_param('/Adjacency_matrix')):
            print("\nMSRPA node: Waiting for Adjacency_matrix parameter...")
            rospy.sleep(1)

        A = parse_Adjacency(rospy.get_param("/Adjacency_matrix"))
        print("\nA matrix:")
        print(A)

        MSRPA_master = MSRPA_node(
            n_quads=n_quads,
            n_rovers=n_rovers,
            leader_list=leader_list,
            malicious_list=malicious_list,
            input_Hz=input_Hz,
            eta=eta,
            F=F,
            A=A,
            leader_message=leader_message
       )

        rospy.spin()
    except rospy.ROSInterruptException: pass
