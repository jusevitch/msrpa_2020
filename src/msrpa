#!/usr/bin/env python

# 
#      ____  ___   _____ ______   __          __    
#     / __ \/   | / ___// ____/  / /   ____ _/ /_   
#    / / / / /| | \__ \/ /      / /   / __ `/ __ \  
#   / /_/ / ___ |___/ / /___   / /___/ /_/ / /_/ /  
#  /_____/_/  |_/____/\____/  /_____/\__,_/_.___/   
#                                                   
# 
# Author: James Usevitch
# 
# Description: This file contains the input/output linearization controller for the
#              Hector Quadrotor model in Gazebo. Obstacle avoidance and input constraint satisfaction
#              is calculated using a control barrier function and QP method.
# 


import rospy
import sys
import numpy as np
import argparse
from copy import deepcopy
from msrpa_2020.msg import SimpleMSRPA
from collections import Counter # For efficiently counting message types

# AGENT NUMBERING:
#
# This approach assumes the following numbering:
# Quads are named quad_0 ... quad_(n_quads-1)
# Rovers are named rover_(n_quads) ... rover_(n_quads + n_rovers - 1)
# This is to help make identifying the rows of the Laplacian matrix relating
# to leaders and malicious agents easier
# 
# FOR EXAMPLE, if 2 quads, 2 rovers then the agent list is
# quad0, quad1, rover2, rover3

class MSRPA_node:
    def __init__(self, n_quads=0, n_rovers=0, leader_list=[], malicious_list=[], A=np.array([],dtype=int), input_Hz=10.0, eta=1, F=0, leader_message=SimpleMSRPA()):
        self.n_quads = n_quads
        self.n_rovers = n_rovers
        self.n = n_quads + n_rovers
        self.leader_list = leader_list
        self.malicious_list = malicious_list
        self.A = A
        self.eta = eta
        self.F = F

        self.timestep = 0

        self.normal_list = [i for i in range(self.n) if i not in self.leader_list + self.malicious_list]

        self.broadcast_matrix = np.zeros(self.A.shape)
        print("\n{}".format(self.broadcast_matrix))
        
        self.pubtopics = ["quad" + str(nq) for nq in range(n_quads)]
        self.pubtopics += ["rover" + str(n_quads + nr) for nr in range(n_rovers)]

        self.publist = [rospy.Publisher(topic, SimpleMSRPA, queue_size=1) for topic in self.pubtopics]

        self.timer = rospy.Timer(rospy.Duration(1.0/input_Hz), self.MSRPA_callback)
        
        # MSRPA Message types:
        # 0 : No message
        # 1 : Normal leader message (the nominal message)
        # All other messages: adversarial messages
        # 
        # These values are stored in the broadcasted_matrix / accepted matrix to save on
        # processing speed.
        # TODO :

        self.MSRPA_types = {
            1: leader_message,
        }

        # TODO : Fix the below
        self.MSRPA_list = [SimpleMSRPA() for i in range(self.n)]
        for i in self.leader_list:
            self.MSRPA_list[i] = leader_message

        
        for j in self.malicious_list:
            self.MSRPA_list[j] = self.gen_malicious_message(j)

    def MSRPA_callback(self, leader_messages):
        # Do the main callback function
        
        # Reset at intervals of eta
        if self.timestep == 0:
            self.broadcast_matrix[:,self.normal_list] = 0.0
            

        # Broadcast
        # ith column of A matrix contains out-neighbors of agent i
        # ith row of A matrix contains in-neighbors of agent i
        # for i in normal_list:
            

        # Receive

        # Update

        self.timestep += 1
        self.timestep %= eta

        print("\ntimestep: {}".format(self.timestep))
 




    def select_message(self, number, received_messages):
        # Return None if there aren't at least 2F+1 messages
        if len(received_messages) < (2*F+1):
            return None
            
        count = Counter([n.name for n in received_messages])
        # Return None if there aren't at least F+1 messages of the same type
        if count.most_common()[0][1] < (F+1):
            return None

        # Collect all messages of the most common type
        msg_type = count.most_common()[0][0]
        matching_types = [msg for msg in received_messages if msg.trajectory_type == msg_type]

        # Take median on all elementwise entries
        # TODO: Preallocate this matrix?
        data_matrix = np.stack([msg.data for msg in matching_types])
        median_matrix = np.median(data_matrix, axis=0)

        # Update the agent's broadcasted message
        self.MSRPA_list[number].trajectory_type = msg_type
        self.MSRPA_list[number].data = median_matrix.tolist()


    
    def msg_is_equal(self, msg1, msg2):
        # Tests if two messages are equal

        if msg1.trajectory_type != msg2.trajectory_type:
            return False
        else:
            if any(msg1.data[i] != msg2.data[i] for i in range(len(msg1.data))):
                return False

        return True
        


    def gen_malicious_message(self, number, malicious_message=SimpleMSRPA()):
        # TODO
        if type(number) is int:
            self.MSRPA_types[number] = malicious_message # Insert malicious message here
        else:
            raise ValueError("Input 'number' to gen_malicious_message is not an int")


# DELETE THESE? Python function calls throttle the speed significatnly

# def MSRPA_init():
    # Initialize all values


# def MSRPA_main():
    # Run the main loop here





def parse_Adjacency(flat_A):
    
    n = np.sqrt(len(flat_A))
    if np.floor(n) != n:
        raise RuntimeError('Incorrect number of Adjacency matrix entries: not a square Adjacency matrix.')
    else:
        A = [[] for i in range(n)]
        for j in range(n):
            A[j] = flat_A[j*n:(j+1)*n-1]

    return np.array(L)




if __name__ == "__main__":
    # Takes inputs from command line. 
    # Note that any unexpected inputs passed into argparse will throw an error.

    # rospy.myargv removes ROS custom inputs from the argv vector
    myargv = rospy.myargv(argv=sys.argv)

    # Removes the filename from the arguments. Required when manually passing the array into the parse_args() function.
    myargv = myargv[1:]     
    
    parser = argparse.ArgumentParser(description='msrpa : Node simulating the MS-RPA algorithm for all agents.')
    parser.add_argument('--n_quads', type=int, help="The number of quads in the network.")
    parser.add_argument('--n_rovers', type=int, help="The number of rovers in the network.")
    parser.add_argument('--eta', type=float, help="The parameter eta from the MS-RPA algorithm")
    parser.add_argument('--F', type=float, help="The parameter F from the MS-RPA algorithm. Must be more than number of adversaries.")
    parser.add_argument('--leader_list', nargs='+', type=int, help="Comma-separated list of leader agents, as per MSRPA numbering scheme")
    parser.add_argument('--malicious_list', nargs='+', type=int, help="Comma-separated list of malicious agents, as per MSRPA numbering scheme")
    parser.add_argument('--input_Hz', type=float, help="Hz rate at which to run the MS-RPA algorithm")
    # parser.add_argument('--L', nargs='+', type=int, help="Laplacian matrix. Input as 1D array with rows appended together.")
    args = parser.parse_args(myargv)

    if args.n_quads is not None:
        n_quads = args.n_quads
        
    if args.n_rovers is not None:
        n_rovers = args.n_rovers

    if args.eta is not None:
        eta = args.eta

    if args.F is not None:
        F = args.F

    if args.leader_list is not None:
        leader_list = args.leader_list

    if args.malicious_list is not None:
        malicious_list = args.malicious_list

    if args.input_Hz is not None:
        input_Hz = args.input_Hz

    

    try:
        rospy.init_node('MSRPA_master')

        n = n_quads + n_rovers

        #while(not rospy.has_param('Adjacency_matrix')):
        #    print("\nMSRPA node: Waiting for Adjacency_matrix parameter...")
        #    rospy.sleep(1)

        # A = parse_Adjacency(rospy.get_param("Adjacency_matrix"))
        A = np.eye(4,4)
        MSRPA_master = MSRPA_node(
            n_quads=n_quads,
            n_rovers=n_rovers,
            leader_list=leader_list,
            malicious_list=malicious_list,
            input_Hz=input_Hz,
            eta=eta,
            F=F,
            A=A
       )

        rospy.spin()
    except rospy.ROSInterruptException: pass
