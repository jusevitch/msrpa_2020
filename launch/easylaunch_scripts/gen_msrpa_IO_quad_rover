#!/usr/bin/env python3

# 
#      ____  ___   _____ ______   __          __    
#     / __ \/   | / ___// ____/  / /   ____ _/ /_   
#    / / / / /| | \__ \/ /      / /   / __ `/ __ \  
#   / /_/ / ___ |___/ / /___   / /___/ /_/ / /_/ /  
#  /_____/_/  |_/____/\____/  /_____/\__,_/_.___/   
#                                                   
# 
# Author: James Usevitch
# 
# Description: This file is uses EasyLaunch to generate a launch file for 
#              MSRPA nodes, quads with IO controllers, and rovers with 
#              IO controllers.
# 


import sys

## Append easylaunch directory to path
## !!! PUT THE PATH TO THE EASYLAUNCH FILE HERE !!!
sys.path.append('/media/james/Data/code2/easylaunch')

import easylaunch as EL
import numpy as np
from numpy import cos, sin
from scipy.linalg import circulant

# Parameters

# AGENT NUMBERING:
#
# This approach assumes the following numbering:
# Quads are named quad_0 ... quad_(n_quads-1)
# Rovers are named rover_(n_quads) ... rover_(n_quads + n_rovers - 1)
# 
# FOR EXAMPLE, if 2 quads, 2 rovers then the agent list is
# quad0, quad1, rover2, rover3
#
# The malicious list refers to the placement using this ordering.

n_quads = 1
n_rovers = 0
leader_list = [0]
malicious_list = []

input_Hz_msrpa = 3
eta = 10
F = 1


n = n_quads + n_rovers
k = 3

noise_bool = False

profile_bool = True


# Quad parameters
quad_launch_radius = 4
quad_formation_radius = 3

umax_quad = 2
kp_quad = 2.5
kd_quad = 1

input_Hz_quad = 250


# Rover parameters
rover_launch_radius = 7
rover_formation_radius = 5

vmax_rover = 2
wmax_rover = 2
kp_rover = 2.5
kd_rover = 1
input_Hz_rover = 50




## Helper Functions

def kCirculant_string(k,n):
    vec = circulant([1 if (i <= k and i != 0) else 0 for i in range(n)]).T  # Scipy does columnwise, so need to transpose it
    print(vec)
    return str(vec.flatten().tolist())


# Construct the launch file


launch = EL.launchFile()

# Global launch arguments. Need to rename this in easylaunch.py sometime.

launch.arg = {
    "x": "0.0",
    "y": "0.0",
    "z": "0.0",
    "output": "screen",
    "model": "$(find hector_quadrotor_description)/urdf/quadrotor_hokuyo_utm30lx.gazebo.xacro",
    "controllers": "controller/attitude controller/velocity controller/position",
}



# Include files


# gazebo_include = EL.include(file="$(find msrpa_2020)/gazebo/launch/city_world.launch")
gazebo_include = EL.include(file="$(find gazebo_ros)/launch/empty_world.launch")
# gazebo_include = EL.include(file="$(find msrpa_2020)/launch/empty_world_boxes.launch")
#gazebo_include.arg = {
#    "physics": "bullet"
#}

gazebo_include.arg = {
    "paused": "true"
}

quad_include = [EL.include(file="$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch") for i in range(n_quads)]

for i in range(n_quads):
    quad_include[i].ns = "quad" + str(i)
    quad_include[i].defarg = ["model", "controllers"]
    quad_include[i].arg = {
        "name": "quad" + str(i),
        "tf_prefix": "quad" + str(i),
        "x": str(quad_launch_radius*cos(i*(2*3.14 / n_quads))),
        "y": str(quad_launch_radius*sin(i*(2*3.14 / n_quads)))
    }
 
# FIXME: Revise the numbering to follow the numbering scheme above
rover_include = [EL.include(file="$(find msrpa_2020)/launch/spawn_rover.launch") for i in range(n_rovers)]

for i in range(n_rovers):
    name = "rover" + str(n_quads + i)
    rover_include[i].ns = name
    rover_include[i].arg ={
        "robot_namespace": name,
        "name": name,
        "x": str(rover_launch_radius*cos(i*(2*3.14 / n_rovers))),
        "y": str(rover_launch_radius*sin(i*(2*3.14 / n_rovers))),
        "z": str(0.1)
    }

launch.include = [gazebo_include] + quad_include + rover_include

# Node files

IO_nodes_quads = [EL.node(name=str("IO_ctrl_quad" + str(i)), pkg="msrpa_2020", type="IO_controller_quad") for i in range(n_quads)]

for i in range(n_quads):
    IO_nodes_quads[i].args = "--quad_namespace quad" + str(i)
    IO_nodes_quads[i].args += " --formation_x " + str(quad_formation_radius*cos(i*(2*3.14 / n_quads)))
    IO_nodes_quads[i].args += " --formation_y " + str(quad_formation_radius*sin(i*(2*3.14 / n_quads)))
    IO_nodes_quads[i].args += " --umax " + str(umax_quad)
    IO_nodes_quads[i].args += " --kp " + str(kp_quad)
    IO_nodes_quads[i].args += " --kd " + str(kd_quad)
    IO_nodes_quads[i].args += " --input_Hz " + str(input_Hz_quad)
    IO_nodes_quads[i].output = "screen"
    IO_nodes_quads[i].ns = "quad" + str(i)
    if profile_bool:
        # pprofile version
        IO_nodes_quads[i].launch_prefix = "pprofile --format callgrind --out cachegrind.out.IO_ctrl_quad{}".format(str(i))
        # cProfile version
        # IO_nodes_quads[i].launch_prefix = "python -m cProfile -o IO_ctrl_quad{}.cprof".format(str(i))

IO_nodes_rovers = [EL.node(name=str("IO_ctrl_rover" + str(i)), pkg="msrpa_2020", type="IO_controller_R1") for i in range(n_rovers)]

for i in range(n_rovers):
    IO_nodes_rovers[i].args = "--rover_namespace rover" + str(n_quads + i)
    IO_nodes_rovers[i].args += " --formation_x " + str(rover_formation_radius*cos(i*(2*3.14 / n_rovers)))
    IO_nodes_rovers[i].args += " --formation_y " + str(rover_formation_radius*sin(i*(2*3.14 / n_rovers)))
    IO_nodes_rovers[i].args += " --vmax " + str(vmax_rover)
    IO_nodes_rovers[i].args += " --wmax " + str(wmax_rover)
    IO_nodes_rovers[i].args += " --kp " + str(kp_rover)
    IO_nodes_rovers[i].args += " --kd " + str(kd_rover)
    IO_nodes_rovers[i].args += " --input_Hz " + str(input_Hz_rover)
    IO_nodes_rovers[i].output = "screen"
    IO_nodes_rovers[i].ns = "rover" + str(n_quads + i)
    if profile_bool:
        IO_nodes_rovers[i].launch_prefix="valgrind --tool=callgrind --callgrind-out-file='callgrind.{}.%p'".format("IO_ctrl_rover" + str(i))


launch.node = IO_nodes_quads + IO_nodes_rovers


msrpa = EL.node(name="MSRPA", pkg="msrpa_2020", type="msrpa")
msrpa.output = "screen"
msrpa.args = f"--n_quads {n_quads} --n_rovers {n_rovers} --input_Hz {input_Hz_msrpa} --eta {eta} --F {F}"
if noise_bool:
    msrpa.args += " --noise"

msrpa.ns = "MSRPA"

if profile_bool:
    msrpa.launch_prefix = "valgrind --tool=callgrind --callgrind-out-file='callgrind.msrpa.%p'"

if len(leader_list) > 0:
    leader_list_string = ' '.join(str(i) for i in leader_list)
    msrpa.args += f" --leader_list {leader_list_string}"

if len(malicious_list) > 0:
    malicious_list_string = ' '.join(str(i) for i in malicious_list)
    msrpa.args += f" --malicious_list {malicious_list_string}"

# A matrix as parameter
A_string = kCirculant_string(k,n)
msrpa.rosparam = {
    "/Adjacency_matrix": A_string
}

launch.node += [msrpa]

# Box obstacles

box_node = EL.node(name="obstacle0", pkg="gazebo_ros", type="spawn_model")
box_node.args = "-file $(find msrpa_2020)/models/unit_box/model.sdf"
box_node.args += " -sdf -model obstacle0 -x 0.0 -y 8.0 -z 0.55"

launch.node += [box_node]





# Write the file to XML

if __name__ == "__main__":
    # Command line option
    if len(sys.argv) > 1:
        launchfile_name = sys.argv[1] # Must be 1. The 0th entry of the array will be "msrpa_only.py".
    else:
        launchfile_name = "../" + "city_world_quads_rovers.launch"
    
    launch.write(filename=launchfile_name, verbose=True)
